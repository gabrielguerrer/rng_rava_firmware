/**
 * Copyright (c) 2023 Gabriel Guerrer
 * 
 * Distributed under the MIT license - See LICENSE for details 
 */

/*
The health module implements entropy monitoring tests that adhere to the NIST 
requirements outlined in the "Recommendation for the Entropy Sources" document 
(M. Sonmez, E. Barker, J. Kelsey, K. McKay, M. Baish, and M. Boyle, "Sp800-90b: 
Recommendation for the entropy sources used for random bit generation", National 
Institute of Standards & Technology (NIST), 2018).

Upon powering up the circuit, startup tests are executed by the HEALTH_STARTUP 
class to assess the proper functioning of the noise sources. If the initial 
tests are successful, the circuit becomes ready to receive commands and generate 
random bytes; otherwise, it communicates the failure and rejects randomness 
generation commands while in the task_health_startup_failed() loop.

The startup tests evaluate the probability distributions of the 2-valued bits, 
the 256-valued bytes, and the average pulse count numbers. The bit and bias 
threshold values are chosen to correspond to a probability of 0.001% of 
occurring by chance.

In addition, continuous tests are conducted by the HEALTH_CONTINUOUS class for 
every generated byte while the noise source is operational. The firmware 
implements two NIST recommended tests: repetition count and adaptive proportion. 
The first detects catastrophic failures that may cause the noise source to 
become "stuck" on a single output value for a long period. The second detects a 
loss of entropy that might occur due to some physical failure or external 
factors affecting the noise source. The threshold values for both tests are 
selected to match a probability of 2^-20 of occurring by chance.

Continuous tests' errors do not disable the randomness generation. Instead, 
users can request error information using the send_errors() function, enabling 
them to take appropriate actions based on the failure rate.
*/

#ifndef RAVA_HEALTH_H
#define RAVA_HEALTH_H

#include <stdint.h>

class HEALTH_STARTUP
{
  public:
    HEALTH_STARTUP();
    
    void run_tests();
    bool get_tests_result();
    void send_results();
    
  private:
    bool test_pulse_count_average();
    bool test_bias();

    // Bit and byte bias parameters
    uint32_t bias_n_bytes;
    float bias_abs_treshold, chisq_max_treshold;

    // Bit and byte bias results
    float bias_a, bias_b; 
    bool bias_result = false;

    float chisq_a, chisq_b;
    bool chisq_result = false;

    // Pulse count parameters
    uint32_t pc_n_counts;
    float pc_avg_min, pc_avg_diff_min;

    // Pulse count results
    float pc_avg_a, pc_avg_b; 
    float pc_avg_dif_a, pc_avg_dif_b;
    bool pc_result = false;

    // Global result
    bool result=true;
};

class HEALTH_CONTINUOUS
{
  public:
    HEALTH_CONTINUOUS();

    void run_tests(const uint8_t* const rng_a, const uint8_t* const rng_b);    
    void send_errors();

  private:
    void nist_repetition_count();
    void nist_adaptive_proportion();
    
    uint8_t m_rng_a, m_rng_b;
    uint8_t m_rng_prev_a=0, m_rng_prev_b=0;

    // Repetition count vars
    uint8_t nrc_cutoff;
    uint8_t nrc_counter_a=1, nrc_counter_b=1;
    uint16_t nrc_error_a=0, nrc_error_b=0;

    // Adaptive proportion vars
    uint8_t nap_cutoff;
    uint16_t nap_iter_a=0, nap_iter_b=0;
    uint8_t nap_counter_a=1, nap_counter_b=1;
    uint8_t nap_target_a, nap_target_b;
    uint16_t nap_error_a=0, nap_error_b=0;
};

#endif