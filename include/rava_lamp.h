/**
 * Copyright (c) 2023 Gabriel Guerrer
 *
 * Distributed under the MIT license - See LICENSE for details
 */

/*
The lamp module offers the possibility of using an attached LED to create a
decorative object that employs the RAVA's generated bytes to randomly vary the
LED's intensity based on the statistical deviation from chance expectations.
The greater the deviation, the more intense the light becomes.

In the firmware, the lamp mode is activated when the macros LED_ENABLED and
LED_LAMP are defined in rava_config.h. When activated, the lamp mode initiates
after the startup health tests and continues until the reception of the first
serial command. At that moment, the lamp mode is deactivated, the LEDs are
powered off, and the RAVA circuit resumes its regular operation.

The lamp uses Timer3 as a clock, which is configured to trigger the
ISR (TIMER3_COMPB_vect) interrupt every 50ms (refer to rava_interrupts.h),
subsequently calling LAMP::tick_increment(). The new tick is detected by the
process() function, invoked within the main loop of rava_firmware, leading to
the corresponding LAMP updates.

The lamp mode relies on six parameters stored in the EEPROM memory:
exp_movwin_n_trials, exp_deltahits_sigevt, exp_dur_max_s,
exp_mag_smooth_n_trials, exp_mag_colorchg_thld, and sound_volume
(see rava_config.h for their default values).

The lamp mode is a repetition of experiments lasting a maximum interval of
exp_dur_max_ms. Each experiment starts by randomly choosing a color from eight
possibilities.

Each experiment consists of trials that occur at regular 50ms intervals and
invoked by the experiment_trial() function. The individual trial steps include:

  - Generating 1 random byte by performing an XOR operation on the outputs of
  both channels A and B

  - Obtaining the quantity of 1s bits (hits) in the total of 8 bits

  - Updating the trial_movwin_hits variable, which represents the number of 1s
  within the moving window of the last exp_movwin_n_trials trials

  - Computing the magnitude of excess hits relative to theoretical expectations
  within the moving window

  - Computing the z-score associated with the excess hits using the normal
  approximation to the binomial distribution

  - Transforming the z-score into a double-tailed p-value probability

  - Converting the p-value into a feedback magnitude that ranges from 0 to 255

  - Calculating the average of the last exp_mag_smooth_n_trials magnitude values

  - Adjusting the LED color and intensity according to the average magnitude

If the excess hits exceeds the exp_deltahits_sigevt threshold, and the minimum
session duration of exp_movwin_n_trials trials is met, the experiment concludes
with a color-oscillating pattern and a sound melody, similar to what occurs
during lamp startup. However, if the experiment's maximum duration
exp_dur_max_ms is reached before this threshold is met, the experiment concludes
with a gradual light fade-off pattern.

While the average feedback magnitude primarily modulates the LED intensity, it
can also influence the LED color when the magnitude exceeds
exp_mag_colorchg_thld. This feature is particularly useful because it is
difficult to perceive intensity variations at higher magnitudes. The change in
color serves as an effective indicator, signaling when the experiment is
approaching the threshold for the color-oscillating pattern.

The three parameters exp_dur_max_ms, exp_deltahits_sigevt, and
exp_movwin_n_trials determine the frequency of color-oscillating significant
events per hour. Their default values target ~6 significant events per hour.

The lamp supports a debug mode, allowing it to send the experiment's information
in real time. While in debug mode, incoming serial commands do not disable the
lamp's functionality.
*/

#ifndef RAVA_LAMP_H
#define RAVA_LAMP_H

#include <stdint.h>

#define LAMP_COLORS 8
#define LAMP_SOUND_NOTES 7

class LAMP
{
  public:
    bool validate_setup_pars(uint16_t exp_movwin_n_trials, uint16_t exp_deltahits_sigevt, uint16_t exp_dur_max_s,
      uint8_t exp_mag_smooth_n_trials, uint8_t exp_mag_colorchg_thld, uint8_t sound_volume);

    void setup();
    void setup_ticks();
    void free_memory();
    void stop();

    void setup_sound();
    void sound_invert_notes();

    void tick_increment();
    void tick_jump(uint16_t jump_to);

    void process();
    void process_instructions();
    void process_experiment();

    void experiment_reset_vars();
    void experiment_trial();

    void experiment_debug(bool send_debug_info);
    bool experiment_debugging();

    void send_debug();
    void send_statistics();

  private:
    bool on = false;

    // Configuration vars
    uint16_t exp_deltahits_sigevt, exp_movwin_n_trials, exp_dur_max_s;
    uint8_t exp_mag_smooth_n_trials, exp_mag_colorchg_thld, sound_volume;

    // Trial vars
    uint8_t trial_color, trial_color_idx, trial_color_shift;
    uint32_t trial_i;
    uint16_t trial_draws;
    int16_t trial_movwin_hits, trial_delta_hits;
    float trial_z, trial_p;
    uint8_t trial_mag;

    // Experiment vars
    uint8_t *exp_feedb_mags, *exp_movwin_hits;

    // Experiment stats vars
    uint16_t exp_n=0, exp_n_zsig=0;
    uint16_t exp_colors[LAMP_COLORS] = {0};

    // Ticks vars
    volatile bool tick_new = false;
    volatile uint32_t tick_counter;

    uint16_t ticks_ins_fade_in, ticks_ins_oscilate, ticks_ins_fade_out, ticks_ins_exp_reset, ticks_ins_end;
    uint32_t ticks_exp_start, ticks_exp_end;

    // Sound vars
    uint16_t ticks_ins_notes[LAMP_SOUND_NOTES];
    uint16_t freq_co_notes[LAMP_SOUND_NOTES];

    // Debug var
    bool exp_send_debug = false;
};

#endif